'''
double-linked list
'''
from typing import Iterable

'''
Node
'''
class Node:
    def __init__(self, val):
        self.val = val
        self.next = None
        self.previous = None
    
    def next(self):
        return getattr(self, 'next')
        
    def previous(self):
        return getattr(self, 'previous')

    def is_end(self)->bool:
        if getattr(self, 'next') is None:
            return True
        return False

    def is_head(self)->bool:
        if getattr(self, 'previous') is None:
            return True
        return False
    
'''
double-linked list
'''
class LinkedList:
    def __init__(self, node:Node=None):
        self.curr_node =  Node() if node is None else node
        self.head_node = self.get_head_node()
        self.end_node = self.get_end_node()

    def get_head_node(self)->Node:
        '''
        return head node
        '''
        if self.head_node is None:
            self.head_node = self.curr_node
        if self.head_node.is_head():
            return self.head_node
        self.head_node = self.head_node.previous
        return self.get_head_node()

    def get_end_node(self)->Node:
        '''
        return end node
        '''
        if self.end_node is None:
            self.end_node = self.curr_node
        if not self.end_node.is_end():
            return self.end_node
        self.end_node = self.end_node.next
        return self.get_end_node()

    def append_node(self, val)->Node:
        '''
        append a new node to the end
        '''
        new_node = Node(val) 
        new_node.previous = self.end_node
        # connect new node
        self.end_node.next = new_node
        # update end_ndoe
        self.end_node = new_node
        return new_node
    
    def insert_node(self, node:Node, val)->Node:
        '''
        insert a new node before a certain node
        old connection: previous node --  node
        new connection: previous node --  new node -- node
        '''
        new_node = Node(val)
        # update parent connection
        if not node.is_head():
            previous_node = node.previous
            previous_node.next = new_node
        # update child connection
        new_node.next = node
        node.previous = new_node
        return new_node

    def get_index(self, node:Node)->int:
        '''
        return index of a certain node
        '''
        if node.is_head():
            return 0
        return 1 + self.get_index(node.previous)
    
    def scan_nodes(self)->Iterable:
        '''
        get all nodes from head to end in order
        '''
        i = -1
        curr_node = self.head_node
        if not curr_node.is_end():
            i += 1
            yield (i, curr_node.next)

    def scan_backward(self)->Iterable:
        '''
        get all nodes from end to head in order
        '''
        curr_node = self.back_node
        if not curr_node.is_head():
            yield curr_node.previous

    def delete_node(self, node)->bool:
        '''
        delete a node except head node
        suppose that node exists
        '''
        if not node.is_head():
            previous = node.previous
            previous.next = node.next if node.next else None
            del node
            return True
        else:
            print("can't delete head node")
        return False



    def search_nodes(self, target_val)->Iterable:
        '''
        return node and its index
        '''
        for i, node in self.scan_nodes():
            if node.val == target_val:
                yield (i, node)

    def insert_at_index(self, index:int, val)->Node:
        '''
        insert an new node by index 0-many
        '''
        for i, node in self.scan_nodes():
            if i == index:
                return self.insert_node(node, val)
        return None

    def feed_nodes(self, input:list):
        '''
        feed values into linkedlist
        '''
        for val in input:
            self.append_node(val)

    def delete_node_at_value(self, val)->bool:
        '''
        delete a node by this value
        '''
        this_node = self.search_node(val)
        if this_node:
            return self.delete_node(this_node)
        return False

    def delete_node_at_index(self, index:int)->bool:
        for i, node in self.scan_nodes():
            if i == index:
                return self.delete_node(node)
        return False

    def delete_all_nodes(self)->Node:
        '''
        delete all nodes leaving the head node only
        '''
        for node in self.scan_nodes():
            del node
        return self.head_node

    def update_nodes(self, old_val, new_val)->list:
        '''
        update 0-many node values
        '''
        pool = []
        for node in self.scan_nodes():
            if node.val == old_val:
                node.val = new_val
                pool.append(node)
        return pool

